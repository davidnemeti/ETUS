using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using System;
using System.Collections.Generic;
using System.Linq;

namespace SchemaLanguage
{
    public interface Definition
    {
        Name : Name { get; set; }
    }
    
    [Record]
    public class Name
    {
        public Value : string { get; set; }
    }

    [Record]
    public class NameRef
    {
        public Value : string { get; set; }
    }

    public interface Reference[+TDef]
            where TDef : Definition
    {
        NameRef : NameRef { get; }
        Definition : TDef { get; }
    }

    internal class ReferenceImpl[TDef] : Reference[TDef]
            where TDef : Definition
    {
        public NameRef : NameRef { get; }
        public Definition : TDef { get; set; }
        
        public this(nameRef : NameRef)
        {
            this.NameRef = nameRef;
        }
        
        public this(definition : TDef)
        {
            this.Definition = definition;
            this.NameRef = NameRef(definition.Name.Value);
        }
    }

    public module Extensions
    {
        public GetReference[TDef](this definition : TDef) : Reference[TDef]
            where TDef : Definition
        {
            ReferenceImpl(definition);
        }

        public GetReference[TDef](nameRef : NameRef) : Reference[TDef]
            where TDef : Definition
        {
            ReferenceImpl(nameRef);
        }
    }

    [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                         Nemerle.MacroTargets.Assembly)]
    public macro DefineEntity(entityName)
    syntax ("define", entityName)
    {
        def ctx = Nemerle.Macros.ImplicitCTX();

        def toName(expr)
        {
            | <[ $(name : name) ]> => name
            | _ =>
                Message.Error(expr.Location, "Expected simple name");
                null
        }

            /* NOTE: ctx.IsMainPass currently does not work correctly TODO
             * it's true when called from the IDE, and it's false when called by the compiler (and this is NOT the expected behavior)
             * therefore we omit the check for ctx.IsMainPass here for now...
             */
//        when (ctx.IsMainPass)
        {
            def builder = ctx.Env.Define(
                <[ decl:
                    public class $(toName(entityName))
                    {
                    }
                ]>
            );
            
            builder.Compile();
            
//            MacroHelper.DoTransform(Nemerle.Macros.ImplicitCTX(), className, body);
        }
    }
    
    module MacroHelper
    {
        //public DoTransfrom(typer : Typer, className : PExpr, body : PExpr) : void
        //{
        //    Macros.DefineCTX(typer);
            
        //    def builder = typer.Env.Define(
        //        <[ decl:
        //            public class $(className)
        //            {
        //            }
        //        ]>
        //    );
            
        //    builder.Define(body);
        //}
    }
}
